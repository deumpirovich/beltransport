<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Транспорт Минска — Реестр списания</title>
  <style>
    body { font-family: 'Segoe UI', Arial, sans-serif; font-size: 13px; background: #f5f7fa; color: #23263a; margin: 0; padding: 0;}
    .cont { max-width: 1200px; margin: 15px auto; padding: 0 10px; }

    .stickyTop{
      position: sticky;
      top: 0;
      z-index: 100;
      background: #f5f7fa;
      padding-top: 10px;
      padding-bottom: 8px;
      border-bottom: 1px solid #e3e8f5;
    }

    .msg {color:#b25127;margin:5px 0; line-height:1.25;}
    .topbar{display:flex; align-items:center; gap:10px; flex-wrap:wrap;}
    .search {margin:6px 0 7px 0; display:flex; align-items:center; gap:10px; flex-wrap:wrap;}
    .tabs{display:flex; gap:6px; flex-wrap:wrap; margin:6px 0 4px 0;}
    .tab{padding:3px 10px; border-radius:10px; border:1px solid #cfd7ea; background:#eef3ff; cursor:pointer; user-select:none; font-size:12px; white-space:nowrap;}
    .tab.active{background:#2543a5; color:#fff; border-color:#2543a5;}
    .counts{color:#5b6b98; font-size:12px; margin-left:auto;}

    /* контейнер таблицы */
    .tableWrap{
      margin-top: 8px;
      overflow-x: auto;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      max-height: 60vh;
      border-radius: 8px;
      background: transparent;
    }

    table{
      border-collapse: collapse;
      background:#fff;
      border-radius:8px;
      overflow:hidden;
      font-size:13px;

      /* ширину задаём colgroup-ом; таблицу не растягиваем на 100% */
      width: auto;
      table-layout: fixed; /* ВАЖНО: после задания col widths, фиксируем layout */
    }

    th, td{
      padding: 6px 6px;
      text-align: center;
      vertical-align: middle;

      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* переносы только для "Номер" и "Примечание" */
    th.wrapNum, td.wrapNum,
    th.wrapNote, td.wrapNote{
      white-space: normal;
      overflow: visible;
      text-overflow: clip;
      word-break: break-word;
      overflow-wrap: anywhere;
      line-height: 1.2;
    }

    thead th{
      position: sticky;
      top: 0;
      z-index: 3;
      background:#ecf1fa;
      border-bottom: 1.5px solid #abc;
    }

    thead tr.filters th{
      position: sticky;
      top: var(--filtersTop, 34px);
      z-index: 3;
      background:#ecf1fa;
      border-bottom: 1.5px solid #abc;
      padding: 4px 6px 6px 6px;
      cursor: default;
    }

    th { color: #2543a5; font-weight: 600; cursor: pointer; user-select: none; }
    th.active { background: #d2e3ff; }
    tr { border-bottom: 1px solid #eee;}
    tbody tr:hover { background: #f0f5ff;}
    .num { font-weight: bold; color: #2543a5; }

    .no { color:#bbb; font-style:italic; }
    .empty {padding:18px 0; text-align:center; color:#9aa6c3; font-style:italic;}
    .err {margin-top:8px; padding:6px 10px; background:#ffecec; border:1px solid #f2b0b0; border-radius:6px; color:#8b1e1e; font-size:12px; white-space:pre-wrap;}

    .colFilter{
      width: 100%;
      box-sizing: border-box;
      padding: 3px 6px;
      font-size: 12px;
      border-radius: 6px;
      border: 1px solid #bbc;
      outline: none;
      background: #fff;
      text-align: center;
      min-width: 40px; /* реальная ширина будет учтена измерением */
    }
    .colFilter:focus{ border-color:#2543a5; }

    td.muted{
      color:#8b95a7;
      font-style:italic;
      font-weight: normal;
    }

    /* вспомогательный “измеритель” */
    #measureBox{
      position: absolute;
      left: -99999px;
      top: -99999px;
      visibility: hidden;
      white-space: nowrap;
      padding: 6px 6px; /* как у td/th */
      font-size: 13px;
      font-family: 'Segoe UI', Arial, sans-serif;
    }
  </style>
</head>
<body>
<div class="cont">
  <div class="stickyTop" id="stickyTop">
    <div class="topbar">
      <div class="msg"><span id="monthHint" style="color:#5b6b98;"></span></div>
      <div class="counts"><span id="countShown">0</span> / <span id="countAll">0</span></div>
    </div>

    <div class="search">
      <div style="color:#5b6b98;font-size:12px;" id="updatedAt"></div>
    </div>

    <div class="tabs" id="tabs"></div>
  </div>

  <div class="tableWrap" id="tableWrap">
    <table id="tbl">
      <!-- NEW: colgroup для управления ширинами -->
      <colgroup id="colgroup"></colgroup>

      <thead>
        <tr id="headRow">
          <th data-f="type">Тип</th>
          <th data-f="model">Модель</th>
          <th data-f="year">Год</th>
          <th data-f="park">Парк</th>
          <th data-f="vehicleNumber" class="active wrapNum">Номер</th>
          <th data-f="exNumber">Экс-номер</th>
          <th data-f="garageNumber">Гаражный №</th>
          <th data-f="factoryNumber">Заводской №</th>
          <th data-f="writeoffDate">Дата вывода</th>
          <th data-f="note" class="wrapNote">Примечание</th>
        </tr>

        <tr class="filters" id="filterRow">
          <th><input class="colFilter" data-col="type"></th>
          <th><input class="colFilter" data-col="model"></th>
          <th><input class="colFilter" data-col="year"></th>
          <th><input class="colFilter" data-col="park"></th>
          <th><input class="colFilter" data-col="vehicleNumber"></th>
          <th><input class="colFilter" data-col="exNumber"></th>
          <th><input class="colFilter" data-col="garageNumber"></th>
          <th><input class="colFilter" data-col="factoryNumber"></th>
          <th><input class="colFilter" data-col="writeoffDate"></th>
          <th><input class="colFilter" data-col="note"></th>
        </tr>
      </thead>

      <tbody id="data"></tbody>
    </table>
  </div>

  <div class="empty" id="empty" style="display:none;">Нет данных по фильтру</div>
  <div class="err" id="err" style="display:none;"></div>
</div>

<div id="measureBox"></div>

<script>
const JSON_URL = './spisanie.json';

let DATA = [];
let VIEW = [];

let sortF = "writeoffDate";
let sortDesc = true;

let activeTab = "_new";
let newMonthKey = '';
let hasCurrentMonth = false;

function pad2(n){ return String(n).padStart(2,'0'); }

/* ===== sticky sizes ===== */
function updateStickyMetrics(){
  const wrap = document.getElementById('tableWrap');
  const stickyTop = document.getElementById('stickyTop');
  if(wrap && stickyTop){
    const topH = Math.max(0, Math.round(stickyTop.getBoundingClientRect().height));
    wrap.style.maxHeight = `calc(100vh - ${topH + 25}px)`;
  }
  const headRow = document.getElementById('headRow');
  if(headRow){
    const h = Math.max(0, Math.ceil(headRow.getBoundingClientRect().height));
    document.documentElement.style.setProperty('--filtersTop', h + 'px');
  }
}
window.addEventListener('resize', ()=> {
  updateStickyMetrics();
  requestAnimationFrame(applyMeasuredColumnWidths);
});

/* ===== NEW month ===== */
function monthKeyFromWriteoffDate(s){
  const m = String(s||'').trim().match(/^(\d{1,2})\.(\d{4})$/);
  if(!m) return '';
  return `${pad2(m[1])}.${m[2]}`;
}
function currentMonthKey(){
  const d = new Date();
  return `${pad2(d.getMonth()+1)}.${d.getFullYear()}`;
}
function computeNewMonthKey(){
  const months = new Set();
  DATA.forEach(v=>{
    const mk = monthKeyFromWriteoffDate(v.writeoffDate);
    if(mk) months.add(mk);
  });

  if(!months.size){
    newMonthKey = '';
    hasCurrentMonth = false;
    document.getElementById('monthHint').textContent = '';
    return;
  }

  const cur = currentMonthKey();
  hasCurrentMonth = months.has(cur);

  if(hasCurrentMonth){
    newMonthKey = cur;
  } else {
    newMonthKey = [...months].sort((a,b)=>{
      const [am,ay]=a.split('.'); const [bm,by]=b.split('.');
      return Number(by+bm) - Number(ay+am);
    })[0];
  }

  document.getElementById('monthHint').textContent =
    newMonthKey ? `NEW: ${newMonthKey}${hasCurrentMonth ? '' : ' (последний месяц со списаниями)'}` : '';
}

/* ===== types ===== */
function normType(t){ return (t||'').toString().trim().toLowerCase(); }
function typeLabel(t){
  t = normType(t);
  if(t === 'автобус') return 'Автобус';
  if(t === 'троллейбус') return 'Троллейбус';
  if(t === 'трамвай') return 'Трамвай';
  if(t === 'электробус') return 'Электробус';
  return t ? (t[0].toUpperCase()+t.slice(1)) : '—';
}
const TYPE_ORDER = {'автобус': 0, 'троллейбус': 1, 'трамвай': 2, 'электробус': 3};
function typeWeight(t){
  t = normType(t);
  return Object.prototype.hasOwnProperty.call(TYPE_ORDER, t) ? TYPE_ORDER[t] : 999;
}

/* ===== tabs ===== */
const TAB_ORDER = [
  {key:'_new', label:'NEW'},
  {key:'автобус', label:'Автобус'},
  {key:'троллейбус', label:'Троллейбус'},
  {key:'трамвай', label:'Трамвай'},
  {key:'электробус', label:'Электробус'},
  {key:'_all', label:'Все'}
];

function calcTypeCounts(){
  const m = {};
  DATA.forEach(v=>{
    const t = normType(v.type);
    if(!t) return;
    m[t] = (m[t]||0)+1;
  });
  return m;
}
function countForNew(){
  if(!newMonthKey) return 0;
  return DATA.filter(v => monthKeyFromWriteoffDate(v.writeoffDate) === newMonthKey).length;
}
function renderTabs(){
  const wrap = document.getElementById('tabs');
  const typeCounts = calcTypeCounts();
  const newCount = countForNew();

  wrap.innerHTML = TAB_ORDER.map(t => {
    let c = 0;
    if(t.key === '_new') c = newCount;
    else if(t.key === '_all') c = DATA.length;
    else c = (typeCounts[t.key] || 0);

    return `<div class="tab ${activeTab===t.key?'active':''}" data-tab="${t.key}">
      ${t.label} <span style="opacity:.75;">${c}</span>
    </div>`;
  }).join('');

  wrap.querySelectorAll('.tab').forEach(el=>{
    el.onclick = ()=>{
      activeTab = el.getAttribute('data-tab');
      renderTabs();
      render();
    };
  });
}

/* =========================
   SORTING
   ========================= */
function canonToRU(ch){
  const map = {'A':'А','B':'В','C':'С','E':'Е','H':'Н','K':'К','M':'М','O':'О','P':'Р','T':'Т','X':'Х','Y':'У','I':'И','І':'И'};
  const u = (ch||'').toString().toUpperCase();
  return map[u] || u;
}
function normPlateRU(s){
  s = (s || '').toString().trim().toUpperCase();
  s = s.replace(/\s+/g, '');
  s = s.replace(/[A-ZА-ЯІ]/g, ch => canonToRU(ch));
  return s;
}
function getPrefix2(plateRU){
  const m = plateRU.match(/^([А-Я]{2})/);
  return m ? m[1] : '';
}
function getNum4(plateRU){
  const m = plateRU.match(/^[А-Я]{2}(\d{4})/);
  return m ? parseInt(m[1], 10) : null;
}
function busPriorityKey(plateRU){
  const p2 = getPrefix2(plateRU);
  const n4 = getNum4(plateRU);

  if(plateRU.startsWith('КС0039')) return {w: 700, d: 39};
  if(plateRU.startsWith('КС0040')) return {w: 710, d: 40};
  if(plateRU.startsWith('КЕ0100')) return {w: 720, d: 100};

  if(p2 === 'КА' && n4 !== null && n4 >= 0 && n4 <= 3999) return {w: 100, d: n4};
  if(p2 === 'КВ') return {w: 200, d: (n4 ?? 9999)};
  if(p2 === 'КЕ' && n4 !== null && n4 >= 0 && n4 <= 5999) return {w: 300, d: n4};
  if(p2 === 'КС' && n4 !== null && n4 >= 1000 && n4 <= 9999) return {w: 400, d: n4};
  if(p2 === 'КИ') return {w: 500, d: (n4 ?? 9999)};
  if(p2 === 'КА' && n4 !== null && n4 >= 4000 && n4 <= 9999) return {w: 600, d: n4};

  if(p2 === 'МА') return {w: 800, d: (n4 ?? 9999)};
  if(p2 === 'КЕ' && n4 !== null && n4 >= 6000 && n4 <= 9999) return {w: 900, d: n4};
  if(p2 === 'КН') return {w: 1000, d: (n4 ?? 9999)};

  const tailOrder = ['АА','АВ','АЕ','АИ','АК','АМ','АН','АО','АР','АС','АТ','АХ','ВА','ВВ'];
  const idx = tailOrder.indexOf(p2);
  if(idx !== -1) return {w: 1100 + idx, d: (n4 ?? 9999)};

  return {w: 9999, d: (n4 ?? 9999)};
}
function comparePlateRU(aRU, bRU){
  if(aRU < bRU) return -1;
  if(aRU > bRU) return 1;
  return 0;
}
function numSortAlg(a, b){
  const aRaw = (a.vehicleNumber || '').toString().trim();
  const bRaw = (b.vehicleNumber || '').toString().trim();

  if(!aRaw && !bRaw) return 0;
  if(!aRaw) return 1;
  if(!bRaw) return -1;

  const aRU = normPlateRU(aRaw);
  const bRU = normPlateRU(bRaw);

  const tA = normType(a.type);
  const tB = normType(b.type);

  if(tA === 'автобус' && tB === 'автобус'){
    const ak = busPriorityKey(aRU);
    const bk = busPriorityKey(bRU);
    if(ak.w !== bk.w) return ak.w - bk.w;
    if(ak.d !== bk.d) return ak.d - bk.d;
    const r = comparePlateRU(aRU, bRU);
    if(r !== 0) return r;
  }

  const r2 = comparePlateRU(aRU, bRU);
  if(r2 !== 0) return r2;

  const aU = aRaw.toUpperCase();
  const bU = bRaw.toUpperCase();
  if(aU < bU) return -1;
  if(aU > bU) return 1;
  return 0;
}

function normWriteoffDateForSort(s){
  const m = String(s || '').trim().match(/^(\d{1,2})\.(\d{4})$/);
  if(!m) return '';
  return m[2] + pad2(m[1]);
}
function normFactoryForSort(s){
  s = (s || '').toString().trim().toUpperCase();
  s = s.replace(/[\s\-]/g, '');
  s = s.replace(/[A-ZА-ЯІ]/g, ch => canonToRU(ch));
  return s;
}

function basePriorityCompare(a, b){
  const ad = normWriteoffDateForSort(a.writeoffDate);
  const bd = normWriteoffDateForSort(b.writeoffDate);
  if(ad !== bd) return (ad < bd) ? 1 : -1;

  const at = typeWeight(a.type);
  const bt = typeWeight(b.type);
  if(at !== bt) return at - bt;

  return numSortAlg(a, b);
}

function generalSort(a, b){
  if(sortF === "vehicleNumber") {
    const r = numSortAlg(a, b);
    if(r !== 0) return sortDesc ? -r : r;
    return basePriorityCompare(a, b);
  }

  let av, bv;

  if(sortF === "writeoffDate"){
    av = normWriteoffDateForSort(a.writeoffDate);
    bv = normWriteoffDateForSort(b.writeoffDate);
  } else if(sortF === "factoryNumber"){
    av = normFactoryForSort(a.factoryNumber);
    bv = normFactoryForSort(b.factoryNumber);
  } else if(sortF === "type"){
    av = typeWeight(a.type);
    bv = typeWeight(b.type);
  } else {
    av = (a[sortF]||'').toString().toLowerCase();
    bv = (b[sortF]||'').toString().toLowerCase();
  }

  if(av < bv) return sortDesc ? 1 : -1;
  if(av > bv) return sortDesc ? -1 : 1;

  return basePriorityCompare(a, b);
}

/* =========================
   RENDER HELPERS
   ========================= */
function escapeHTML(s){
  return String(s).replace(/[&<>"']/g, c => ({
    '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
  }[c]));
}
function cellText(x){
  return (x||'').toString().trim();
}
function cellHTML(x){
  const s = cellText(x);
  return s ? escapeHTML(s) : '<span class="no">—</span>';
}
function normVehicleNumberForSearch(s){
  s = (s || '').toString().trim().toUpperCase();
  s = s.replace(/[\s\-]/g, '');
  s = s.replace(/[A-ZА-ЯІ]/g, ch => canonToRU(ch));
  return s;
}
function isMuted(v, key){
  return !!(v && v.gray && typeof v.gray === 'object' && v.gray[key]);
}
function tdClass(v, key, baseClass=''){
  const c = [];
  if(baseClass) c.push(baseClass);
  if(isMuted(v, key)) c.push('muted');
  return c.length ? ` class="${c.join(' ')}"` : '';
}

/* ===== hide empty columns ===== */
const COLS = [
  {key:'type',        label:'Тип'},
  {key:'model',       label:'Модель'},
  {key:'year',        label:'Год'},
  {key:'park',        label:'Парк'},
  {key:'vehicleNumber', label:'Номер', wrap:true, maxWidth: 180},
  {key:'exNumber',    label:'Экс-номер'},
  {key:'garageNumber',label:'Гаражный №'},
  {key:'factoryNumber',label:'Заводской №'},
  {key:'writeoffDate',label:'Дата вывода'},
  {key:'note',        label:'Примечание', wrap:true, maxWidth: 320}
];

function isEmptyByKey(v, key){
  if(key === 'type') return !normType(v.type);
  return !cellText(v[key]);
}

function setColumnVisibility(visibleKeys){
  const keys = new Set(visibleKeys);

  const thRow = document.getElementById('headRow');
  const filterRow = document.getElementById('filterRow');

  const ths = Array.from(thRow.children);
  const fths = Array.from(filterRow.children);

  COLS.forEach((c, idx)=>{
    const show = keys.has(c.key);
    if(ths[idx]) ths[idx].style.display = show ? '' : 'none';
    if(fths[idx]) fths[idx].style.display = show ? '' : 'none';
  });
}

function computeVisibleCols(){
  const visible = [];
  for(const c of COLS){
    const anyNonEmpty = VIEW.some(v => !isEmptyByKey(v, c.key));
    if(anyNonEmpty) visible.push(c.key);
  }
  return visible;
}

/* ===== NEW: измерение и установка ширин колонок ===== */
function textWidthPx(txt){
  const box = document.getElementById('measureBox');
  box.textContent = txt || '';
  return Math.ceil(box.getBoundingClientRect().width);
}

function applyMeasuredColumnWidths(){
  const thRow = document.getElementById('headRow');
  const filterRow = document.getElementById('filterRow');
  const colgroup = document.getElementById('colgroup');
  if(!thRow || !filterRow || !colgroup) return;

  const ths = Array.from(thRow.children);
  const fths = Array.from(filterRow.children);

  // актуальные видимые колонки (по display)
  const visibleIdx = [];
  for(let i=0;i<COLS.length;i++){
    if(ths[i] && ths[i].style.display !== 'none') visibleIdx.push(i);
  }

  // rebuild colgroup in original order, but set width 0 for hidden
  colgroup.innerHTML = '';
  const widths = new Array(COLS.length).fill(0);

  // базовые ограничения
  const PAD = 16;                 // запас
  const MIN_W = 40;               // минимальная ширина
  const MAX_W_DEFAULT = 260;      // чтобы какие-то поля не раздувались бесконечно

  // меряем
  visibleIdx.forEach(i=>{
    const col = COLS[i];

    // 1) заголовок
    let w = textWidthPx(col.label) + PAD;

    // 2) значение фильтра (placeholder нет, но input имеет минимальную полезную ширину)
    // берём текущий текст в инпуте, либо минимальную ширину по размеру поля
    const inp = fths[i] ? fths[i].querySelector('input') : null;
    if(inp){
      const val = (inp.value || '').trim();
      if(val) w = Math.max(w, textWidthPx(val) + PAD);
      // чтобы инпут не был микроскопическим
      w = Math.max(w, 70);
    }

    // 3) данные (по текущему VIEW!)
    // берём максимум по нескольким первым N строкам (ускорение),
    // но учитываем все для небольших таблиц
    const N = VIEW.length <= 400 ? VIEW.length : 400;
    for(let k=0;k<N;k++){
      const v = VIEW[k];
      let txt = '';
      if(col.key === 'type') txt = typeLabel(v.type);
      else txt = cellText(v[col.key]);

      if(!txt) continue;

      // для wrap-колонок считаем ширину, но режем maxWidth (чтобы не раздували)
      const tw = textWidthPx(txt) + PAD;
      w = Math.max(w, tw);
    }

    // ограничения
    w = Math.max(w, MIN_W);

    if(col.wrap && col.maxWidth){
      w = Math.min(w, col.maxWidth);
    } else {
      w = Math.min(w, MAX_W_DEFAULT);
    }

    widths[i] = w;
  });

  // применяем ширины через colgroup
  for(let i=0;i<COLS.length;i++){
    const colEl = document.createElement('col');
    if(widths[i] > 0) colEl.style.width = widths[i] + 'px';
    else colEl.style.width = '0px';
    colgroup.appendChild(colEl);
  }
}

/* =========================
   RENDER
   ========================= */
function render(){
  const colFilters = {};
  document.querySelectorAll('.colFilter').forEach(inp=>{
    const col = inp.getAttribute('data-col');
    const val = (inp.value || '').toString().trim();
    if(val) colFilters[col] = val;
  });

  VIEW = DATA
    .filter(v=>{
      if(activeTab === '_new'){
        if(!newMonthKey) return false;
        const mk = monthKeyFromWriteoffDate(v.writeoffDate);
        if(mk !== newMonthKey) return false;
      }
      if(activeTab !== '_new' && activeTab !== '_all'){
        if(normType(v.type) !== activeTab) return false;
      }

      for(const [col, rawNeedle] of Object.entries(colFilters)){
        const needle = rawNeedle.toString().toLowerCase();

        if(col === 'type'){
          const hay = typeLabel(v.type).toLowerCase();
          if(!hay.includes(needle)) return false;
          continue;
        }

        if(col === 'vehicleNumber' || col === 'exNumber' || col === 'garageNumber' || col === 'factoryNumber'){
          const hay = normVehicleNumberForSearch(v[col]);
          const n = normVehicleNumberForSearch(rawNeedle);
          if(!hay.includes(n)) return false;
          continue;
        }

        const hay = (v[col] || '').toString().toLowerCase();
        if(!hay.includes(needle)) return false;
      }

      return true;
    })
    .sort(generalSort);

  document.getElementById('countShown').textContent = VIEW.length;
  document.getElementById('countAll').textContent = DATA.length;

  const tbody = document.getElementById('data');
  const empty = document.getElementById('empty');

  if(!VIEW.length){
    tbody.innerHTML = '';
    empty.style.display = '';
    setColumnVisibility(COLS.map(c=>c.key));
    requestAnimationFrame(()=> {
      updateStickyMetrics();
      applyMeasuredColumnWidths();
    });
    return;
  }
  empty.style.display = 'none';

  const visibleCols = computeVisibleCols();
  setColumnVisibility(visibleCols);
  const visibleSet = new Set(visibleCols);

  tbody.innerHTML = VIEW.map(v=>{
    const num = cellText(v.vehicleNumber);
    const exn = cellText(v.exNumber);
    const gar = cellText(v.garageNumber);
    const fac = cellText(v.factoryNumber);

    const cells = [];

    if(visibleSet.has('type')) cells.push(`<td${tdClass(v,'type')}>${escapeHTML(typeLabel(v.type))}</td>`);
    if(visibleSet.has('model')) cells.push(`<td${tdClass(v,'model')}>${cellHTML(v.model)}</td>`);
    if(visibleSet.has('year')) cells.push(`<td${tdClass(v,'year')}>${cellHTML(v.year)}</td>`);
    if(visibleSet.has('park')) cells.push(`<td${tdClass(v,'park')}>${cellHTML(v.park)}</td>`);

    if(visibleSet.has('vehicleNumber')) cells.push(`<td${tdClass(v,'vehicleNumber','num wrapNum')} title="${escapeHTML(num)}">${cellHTML(num)}</td>`);
    if(visibleSet.has('exNumber')) cells.push(`<td${tdClass(v,'exNumber')} title="${escapeHTML(exn)}">${cellHTML(exn)}</td>`);
    if(visibleSet.has('garageNumber')) cells.push(`<td${tdClass(v,'garageNumber')} title="${escapeHTML(gar)}">${cellHTML(gar)}</td>`);
    if(visibleSet.has('factoryNumber')) cells.push(`<td${tdClass(v,'factoryNumber')} title="${escapeHTML(fac)}">${cellHTML(fac)}</td>`);

    if(visibleSet.has('writeoffDate')) cells.push(`<td${tdClass(v,'writeoffDate')} title="${escapeHTML(v.writeoffDate||'')}">${cellHTML(v.writeoffDate)}</td>`);
    if(visibleSet.has('note')) cells.push(`<td${tdClass(v,'note','wrapNote')}>${cellHTML(v.note)}</td>`);

    return `<tr>${cells.join('')}</tr>`;
  }).join('');

  requestAnimationFrame(()=> {
    updateStickyMetrics();
    applyMeasuredColumnWidths();
  });
}

/* clicks */
document.querySelectorAll('th[data-f]').forEach(th=>{
  th.onclick = ()=>{
    document.querySelectorAll('th[data-f]').forEach(t=>t.classList.remove('active'));
    th.classList.add('active');

    const f = th.getAttribute('data-f');
    if(sortF === f) sortDesc = !sortDesc;
    else {
      sortF = f;
      sortDesc = (f === 'writeoffDate') ? true : false;
    }
    render();
  };
});

/* filters */
document.addEventListener('input', (e) => {
  if(e.target && e.target.classList && e.target.classList.contains('colFilter')){
    render();
  }
});

/* errors */
function showErr(msg){
  const e = document.getElementById('err');
  e.style.display = '';
  e.textContent = msg;
}
function hideErr(){
  const e = document.getElementById('err');
  e.style.display = 'none';
  e.textContent = '';
}

/* json mapping */
function pickArray(j){
  if(Array.isArray(j)) return j;
  if(j && Array.isArray(j.vehicles)) return j.vehicles;
  if(j && Array.isArray(j.data)) return j.data;
  if(j && Array.isArray(j.items)) return j.items;
  return [];
}
function mapRow(r){
  return {
    type: r.type || '',
    model: r.model || '',
    year: r.year || '',
    park: r.park || '',
    vehicleNumber: (r.licensePlate || r.registrationNumber || r.vehicleNumber || ''),
    exNumber: r.exNumber || '',
    garageNumber: r.garageNumber || '',
    factoryNumber: r.factoryNumber || '',
    writeoffDate: r.writeoffDate || '',
    note: r.note || '',
    gray: (r.gray && typeof r.gray === 'object') ? r.gray : {}
  };
}

async function loadJson(){
  try{
    hideErr();
    const r = await fetch(JSON_URL, {cache:'no-store'});
    if(!r.ok) throw new Error('HTTP '+r.status);
    const j = await r.json();

    const arr = pickArray(j);
    const updatedAt = (j && !Array.isArray(j) && j.updatedAt) ? j.updatedAt : '';

    DATA = arr.map(mapRow);
    document.getElementById('updatedAt').textContent = updatedAt ? ('Обновлено: ' + updatedAt) : '';

    computeNewMonthKey();

    activeTab = "_new";
    sortF = "writeoffDate";
    sortDesc = true;

    renderTabs();
    render();
  } catch(err){
    DATA = [];
    renderTabs();
    render();
    showErr('Ошибка: ' + err.message);
  }
}

renderTabs();
loadJson();
</script>
</body>
</html>